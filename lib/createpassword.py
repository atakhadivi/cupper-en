# -*- coding:utf-8 -*-

import time
import itertools
import re
import os
from lib.oldpasswordAnalyze import AnalyzeGetNumbers
from lib.common import FilterList,CountSpecialCharacter,getNameList
from lib.situationhandle import SituationHandle
from lib.passwordDeform import *
"""
MixedKeywordList property:Each element is directly a list of elements of the MixedKeywordList in preHandlePhase
"""

class PasswordGenerator(object):
    '''
    Password generator.
    '''
    #Key figures appearing in high frequency universal passwords
    _numList =['123456', '123123','1314','123','321','52']
    """The number originally selected by the author
    _numList = ['123456', '123123', '123123123', '112233', '445566', '456456', \
    '789789', '778899', '321321', '521','520', '1314', '5201314', '1314520', '147369', \
    '147258', '258', '147', '456', '789', '147258369', '111222', '123', '1234', \
    '12345', '1234567', '12345678', '123456789', '987654321', '87654321', '7654321', \
    '654321', '54321', '4321', '321','52']
    """

    # Common prefix list
    _prefixWords = ['a','qq','yy','aa','abc','qwer','woaini']

    #Common suffix list,Is a mosaic list,[0]Is a list of English characters,[1]Is a list of numeric characters
    _suffixwords = [['a'],[str(x) for x in xrange(0,10)]+['520']]

    #The connection string between the embedding and the embedding, or the embedding and center list
    #Note that the list here must have''Element, otherwise in the Mixed series function for j in self.Add r before _connList.append(a+b)
    _connList=['','_']  #['','#','*','_','@','.']

    #Companion prefix list
    _partnerPrefixList = ['520','5201314','1314','iloveu','iloveyou']

    #High frequency universal MixedKeywordList vocabulary without suffix deformation processing
    _commonMixWordsList=['']   #['password']

    #Parameter setting
    min_len= 5#Minimum password length, excluding
    max_len= 17#Maximum password length, excluding

    def __init__(self,PI):
        '''
        parameter:
            Meaning of each attribute value of the passed PI parameter:
            fullnameList:  Fullname unit:Full name of the target,The pinyin of each word is separated by a space,All lowercase,Supports up to three words of name
            nicknameList:  Nickname unit:nickname
            dateList:  List of important dates including birthdays,format:19980405
            phoneList:   telephone number
            oldpasswdList:  old password,List
            keynumbersList:  Possible numbers are a list
            keywordsList:    Keywords, is a list, all lowercase
            lovername:   Love person's name,The pinyin of each word is separated by a space, all lowercase,Supports up to three words of name
            organizationList:   Full name of the institution(Including work unit), the pinyin of each word is separated by a space, all lowercase
            qq:          Target QQ number
            weakpasswd:  Logic value, 1 or 0. 1 means to add the built-in weak password password in front of the generated password.
            situation    dictionary Contains scenario information and user information collected in the scenario
        '''
        self.fullnameList = PI.fullnameList
        self.nicknameList = PI.nicknameList
        self.dateList = PI.dateList
        self.phoneList = PI.phoneList
        self.oldpasswdList = PI.oldpasswdList   #The digital part of it plays a role,Also need to extract the string
        self.keynumbersList = PI.keynumbersList
        self.keywordsList = PI.keywordsList
        self.lovernameList = PI.lovernameList
        self.organizationList = PI.organizationList
        self.qq = PI.qq
        self.situation = PI.situation
        self.weakpasswd = PI.weakpasswd  #最后由lastHandlePhase处理


        ###Here are the variables that hold the vocabulary that needs to be embedded in other embedding and center lists.
        #Predict the list of numeric embeddings that the target password might contain
        self.InnerNumList=[]
        #a list of abbreviated inserts generated by a full name
        self.ShortNameList=[]
        #List of non-abbreviated insets generated by full name
        self.FullNameList=[]
        #List of insets generated by the company's full name
        self.CompanyList=[]
        #List of pliers generated from scene related information
        self.SituationList=[]

        #Prefix list embedding
        self.PrefixList=[]
        #	Suffix list embedding
        self.SuffixList=[]

        #The center list of the embedded embedded, note:This list will be added directly to self.result
        self.MixedKeywordList=[]
        
    
        self.result=[]#The resulting list of passwords

    def __GetBirthNumList(self):#Must return the birthday parameter passed unchanged without changing
        r =[]
        for date in self.dateList:
            year = date[0:4]
            month = date[4:6]
            day = date[6:8]
            r += [year+month+day,year,month+day,day,year[2:4],year[2:4]+month+day, \
            day+month+year]
            #If you use month[0], when the user does not pass the birthday message, month='', an IndexError will be raised here.
            if month[0:1]=='0' or day[0:1]=='0':
                r += [year+month.lstrip('0')+day.lstrip('0')]
        return r
               

    def _GetInnerNumList(self):
        r=self._numList#The previous constant
        #for i in xrange(0,10):
            #r+=[str(i)*x for x in xrange(1,5)]#Repeat each 0 to 9 number 1 to 4 times

        #endyear = int(time.strftime("%Y"))
        ###Is it possible to consider letting the user enter the year instead of guessing?
        #r += [str(x) for x in range(2000, endyear+1)]#Year of generation (2000-present)

        if self.keynumbersList:
            r+=self.keynumbersList
        r += self.__GetBirthNumList()
        if self.oldpasswdList:  #Personally recommend extracting digital content from oldpasswd
            r += AnalyzeGetNumbers(self.oldpasswdList)
        return FilterList(r)
    
    def _GetShortNameList(self,fullnameList=None):
        fullnameList = fullnameList if fullnameList else self.fullnameList
        #print fullnameList
        if not fullnameList:
            return []
        else:
            r = []
            func = lambda x:[x, x.title(), x[0].lower(), x[0].upper(), x.upper()]
            for fullname in fullnameList:
                nameSplited = fullname.split()
                if len(nameSplited) == 1:
                    r += func(nameSplited[0])
                elif len(nameSplited) == 2:
                    shortName = nameSplited[0][0].lower() + nameSplited[1][0].lower()
                    r += func(shortName)
                else:
                    shortName = nameSplited[0][0].lower() + nameSplited[1][0].lower() + nameSplited[2][0].lower()
                    r += func(shortName)
                    shortNameRS = nameSplited[1][0].lower() + nameSplited[2][0].lower() + nameSplited[0][0].lower()
                    shortNameRST = nameSplited[1][0].lower() + nameSplited[2][0].lower() + nameSplited[0][0].title()
                    shortNameR = nameSplited[1][0].lower() + nameSplited[2][0].lower() + nameSplited[0]
                    shortNameRT = nameSplited[1][0].lower() + nameSplited[2][0].lower() + nameSplited[0].title()
                    r += [shortNameRT, shortNameR, shortNameRST, shortNameRS, shortNameRS.upper()]
            return r

    def _GetFullNameList(self,fullnameList=None):
        fullnameList = fullnameList if fullnameList else self.fullnameList
        if not fullnameList:
            return []
        else:
            r = []
            func=lambda x:[x.split(),x.upper().split(),x.title().split()]
            for fullname in fullnameList:
                nameSplited=func(fullname)
                if len(nameSplited[0]) == 1:
                    r += nameSplited[0]
                    r += nameSplited[1]
                    r += nameSplited[2]
                elif len(nameSplited[0]) == 2:
                    func1=lambda x:[x[0]+x[1],x[1]+x[0]]
                    r += func1(nameSplited[0])
                    r += func1(nameSplited[1])
                    r += func1(nameSplited[2])
                else:
                    r += [''.join(nameSplited[0]),''.join(nameSplited[1]),''.join(nameSplited[2])]
                    func2=lambda x:(x[1]+x[2]+x[0])
                    r += [func2(nameSplited[0]),func2(nameSplited[1]),func2(nameSplited[2])]
                    r += [nameSplited[0][1]+nameSplited[0][2]+nameSplited[1][0]]
            return r
        
    def _GetCompanyList(self,organizationList=None):
        organizationList = organizationList if organizationList else self.organizationList
        if not organizationList:
            return []
        else:
            r=[]
            for organization in organizationList:
                r += getNameList(organization)
            return r

    def _GetSituationList(self):
        '''
           Need SituationHandle
        '''
        r=SituationHandle(self.situation)
        return r


    def _OrderMixed(self, listA, listB,samefilter=False):
        if not listA and not listB:
            return []
        r = []
        for a,b in itertools.product(listA, listB):#The part after in generates a tuple of Cartesian product, where the tuple(a,b)
            if samefilter:
                if a==b:
                    continue
            if len(a+b)>self.min_len and len(a+b)<self.max_len:         #Set the maximum length of the connection  
                for j in self._connList:
                    r.append(a+j+b)
        return r

    def _Mixed(self, listA, listB,samefilter=False):
        if not listA and not listB:
            return []
        r = []
        for a,b in itertools.product(listA, listB):#The part after in generates a tuple of Cartesian product, where the tuple(a,b)
            if samefilter:
                if a==b:
                    continue
            if len(a+b)>self.min_len and len(a+b)<self.max_len:         #Filter passwords by length range
                for j in self._connList:
                    r.append(a+j+b)
                    r.append(b+j+a)
                    #Duplicate when b='' or a=''
        return r

    def _TwoLevelMixed(self,listA,listB,listC,samefilter=False):
        '''
           The equivalent mixture is listA, listB, listC, each element is arranged to form an element of r, but there are corresponding filtering rules.
           If there is the same among the three elements arranged as an element of r, then this element is not placed in r
           For programming convenience, only listB and listC are allowed to be the same.
        '''
        if not listA and not listB and not listC:
            return []
        r=[]
        for a,b in itertools.product(listA, listB):
            for c in listC:
                if samefilter:
                    if b==c:
                        continue
                if len(a+b+c)>self.min_len and len(a+b+c)<self.max_len:
                    for j in self._connList:
                        r.append(a+j+b+c)
                        r.append(b+j+a+c)
                        r.append(c+j+a+b)
                        r.append(c+j+b+a)
                        r.append(a+b+j+c)
                        r.append(b+a+j+c)
                        r.append(c+a+j+b)
                        r.append(c+b+j+a)
        return r
            



    def _DecideAddWhat(self,string):#Decide whether to add if you add, add numbers or characters, mainly for self.SuffixList Note is not the same as self._suffixwords
        #Return 2 means no added
        numlist=re.findall(r"\d+",string)
        i=0
        for stringnumber in numlist:
             i += len(stringnumber)
        j=len(string)-i
        if abs(i-j)<=2:
            return -1
        else:
            if ord(string[-1:])>=48 and ord(string[-1:])<=57:
                return 0
            else:
                return 1
        
            
    def preHandlePhase(self):#Generate various inlay lists
        self.InnerNumList=self._GetInnerNumList()
        self.ShortNameList=self._GetShortNameList()
        self.FullNameList=self._GetFullNameList()
        self.CompanyList=self._GetCompanyList()

        TwoNestedList = self._GetSituationList()
        self.SituationList = TwoNestedList[0]
        self.InnerNumList +=  TwoNestedList[1]

        self.PrefixList=self._prefixWords+[x.upper() for x in self._prefixWords]
        self.SuffixList=self._suffixwords#Finally processed in lastHandlePhase,Can't do any addition here

    
        self.MixedKeywordList += self.ShortNameList    
        self.MixedKeywordList += self.FullNameList
        if self.nicknameList:
            self.MixedKeywordList += self.nicknameList
        if self.keywordsList:
            self.MixedKeywordList += self.keywordsList

        self.MixedKeywordList += self.SituationList
        self.MixedKeywordList += self._commonMixWordsList

    def mixedPhase(self):
        self.result += self._Mixed(self.MixedKeywordList, self.InnerNumList)
        self.result += self._Mixed(self.MixedKeywordList,self.CompanyList)
        self.result += self._OrderMixed(self.PrefixList,self.MixedKeywordList)
        self.result += self._Mixed(self.InnerNumList,self.CompanyList)
        
        #Central list of secondary embedding embedded
        TwoLevelMixKeywordList = []
        TwoLevelMixKeywordList += self._TwoLevelMixed(self.MixedKeywordList,self.InnerNumList,self.InnerNumList,True)
        TwoLevelMixKeywordList += self._OrderMixed(self.MixedKeywordList,self.MixedKeywordList,True)
        
        self.result += TwoLevelMixKeywordList
        
        if self.phoneList:
            self.result += self._OrderMixed(self.PrefixList+self.MixedKeywordList, self.phoneList)
            #The phone number can be generated separately, and the last four digits can also be taken out as a member of the InnerNumList.
        if self.qq:
            self.result += self._OrderMixed(self.PrefixList+self.MixedKeywordList,[self.qq])
        if self.lovernameList:
            temlist = self._GetShortNameList(self.lovernameList)+self._GetFullNameList(self.lovernameList)
            self.result += self._OrderMixed(self._partnerPrefixList, temlist)

        #Can be handled separately as a password without mixing with other passwords
        self.result += self.result + self.MixedKeywordList + self.InnerNumList  
        

    def lastHandlePhase(self):
        '''
           deal with self.SuffixList with self.oldpasswdList,self.weakpasswd  Or expand more intelligent processing
        '''
        PassListWithSuffix=[]
        for i in xrange(0,len(self.result)):
            d=self._DecideAddWhat(self.result[i])
            if d==-1:
                continue
            else:
                for suffixchar in self.SuffixList[d]:
                    PassListWithSuffix.append(self.result[i]+suffixchar)
        SimplePasswordList=[]
        if self.weakpasswd:#Digital logic
            f=open('simplepassword','r')#Open this file in the current directorys
            for p in f.readlines():
                if p.strip("\n")!="":
                    SimplePasswordList.append(p.strip("\n"))
            f.close()
        self.result = self.result+SimplePasswordList + self.oldpasswdList + PassListWithSuffix

    def passFilter(self):
        '''
           This function filters out inappropriate passwords, including the following
           1.Duplicate password
           2.Unsuitable password
           3.A password with too many special characters, here more than two passwords
        '''
        #Remove the same element
        #self.result = sorted(set(self.result),key=self.result.index)
        self.result = FilterList(self.result)
        #Remove passwords that are not suitable in length and have two or more special characters
        self.result = [i for i in self.result if (len(i)>self.min_len and len(i)<self.max_len and CountSpecialCharacter(i)<2)]        


    def deform(self):
        '''
           This function uses a transformation mode that some users may use to process the password dictionary.
           See the passwordDeform.py script for details.
           You can fill or modify this function to use the passwordDeform.py script based on your experience.
           What are the rules?.
        '''
        self.result += CapitalizeTheFirstLetter(self.result)
        self.result += charReplace(self.result)
        if '3' in self.situation['mode']:#Whether to judge whether it belongs to"Test objectives understand security scenarios"
            self.result += EncodeConvert(self.result)


    def generator(self):
        self.preHandlePhase()
        self.mixedPhase()
        self.lastHandlePhase()
        self.passFilter()  
        self.deform()    #This can be considered to let the user decide if they need to do this conversion.
        
        #You can use the filter function here.,However, it is best not to have the same password on the password generation process.,The advice here is for
        #Prevent _numList and add weak password passwords to repeat.
        return self.result


if __name__=='__main__':
    pass















        

    
